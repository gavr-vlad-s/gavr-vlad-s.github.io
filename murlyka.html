<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>C/C++ build system Murlyka</title>
	<link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
	<header>
		<h1 id="murlyka-system">C/C++ build system Murlyka</h1>
	</header>
	<nav>
		<p><a href="index.html">Back</a></p>
	</nav>
	<div style="border: 1px dotted black; padding: 5px 5px 0 15px; margin: 5px;">
		<strong>Contents</strong>
		<ol>
			<li><a href="#intro">Introduction</a></li>
			<li><a href="#input-format">Input file format</a></li>
			<li><a href="#examples">Examples</a></li>
				<ul>
					<li><a href="#ex1">Example 1</a></li>
					<li><a href="#ex2">Example 2</a></li>				
				</ul>
			<li><a href="#cmdline">Command line syntax</a></li>
			<li><a href="#building">Building of Murlyka project</a></li>
			<li><a href="#install-haskell">Installing Haskell</a></li>
				<ul>
					<li><a href="#install-win" >For Windows</a></li>
					<li><a href="#install-debian" >For Debian and Debian-based Linux (e.g., Ubuntu Linux, Linux Mint)</a></li>
					<li><a href="#install-arch" >For Arch Linux and for Arch-based Linux (e.g., Manjaro Linux)</a></li>
				</ul>
			<li><a href="#releases">Releases</a></li>
		</ol>
	</div>
	<section>
		<article>
			<h2 id="intro">1. Introduction</h2>
				<p>
					To build projects written on C and C++, various build system are used. The most famous build systems are CMake, 
					GNU Make, Scons, Shake, and the system used to build the Boost libraries. Consider each of these build system.
				</p>				
				<p>
					System GNU Make takes a Makefile describing the build script of the project. Writing this script manually is 
					not very convenient, if there are a lot of source files. The advantage of this system is that this system works 
					both under Linux, and under Windows.
				</p>
				<p>
					Systems SCons and CMake are wrappers over Make utility and generate input files for Make. System SCons is written 
					in language Python 2.7, and has installing problem under Windows 7. There are no installing problems under Linux.
					The inability to work under Windows is disadvantage of this system. The Makefile generated by CMake system, are 
					complicated and contains absolute paths to source files and to compiler. By default, CMake uses C++ compiler, which 
					is standard for an operating system. Standard C++ compiler for Linux is g++ (a compiler from GCC collection). 
					Standard C++ compiler for Windows is a compiler from Microsoft Visual Studio. However, Visual Studio compiler 
					does not fully support recent standards of C++ language, unlike the compiler of the GCC collection. Hence, it is 
					better to use g++ under Windows. But, under Windows, in order for CMake used g++ and the needed keys of g++, you 
					need to write a long chain of command-line arguments. As for Linux, then, in addition to the compiler from collection 
					GCC can be installed, for example, compilers of a set of Clang. Under Linux, in order for CMake used clang, you need to 
					write a long chain of command-line arguments. The build system for the Boost libraries is not recommended by an author 
					of one of Boost library, because it is difficult to use this build system.  
				</p>
				<p>
					The build system Shake is written in Haskell, and requires installed system Haskell Stack. But Haskell Stack does not 
					work under Linux. The purpose of the system Haskell Stack is to write Makefiles as programs in Haskell, then to compile 
					them by Haskell compiler, and to run resulting program. Resulting program will build the needed project. To use in C++ 
					projects, is is disadvantage. Therefore, we need a more simple build system. It is the goal of the project Murlyka.
				</p>
				
				
				
			<h2 id="input-format">2. Input file format</h2>		
				<p>
					Input file consists of an arbitrary sequence the following commands (this sequence can be empty):
				</p>
				<ul>
					<li><strong>project</strong>  (<span class="comargs"><em>project_name main_file</em></span>)</li>
					
					<li><strong>compiler</strong>(<span class="comargs"><em>compiler_name)</em></span></li>
					
					<li><strong>compiler_flags</strong>(<span class="comargs"><em>compiler_flags)</em></span></li>
					
					<li><strong>linker</strong>(<span class="comargs"><em>linker_name)</em></span></li>
					
					<li><strong>linker_flags</strong>(<span class="comargs"><em>linker_flags)</em></span></li>
					
					<li><strong>source_dir</strong>(<span class="comargs"><em>directory_with_source_files)</em></span></li>
					
					<li><strong>source_exts</strong>(<span class="comargs"><em>source_files_extensions)</em></span></li>
					
					<li><strong>build_dir</strong>(<span class="comargs"><em>directory_for_object_files_and_for_program)</em></span></li>
					
					<li><strong>include_dirs</strong>(<span class="comargs"><em>list_of_directories_for_header_files)</em></span></li>
					
					<li><strong>makefile_name</strong>(<span class="comargs"><em>name_for_Makefile)</em></span></li>
					
					<li><strong>libraries</strong>(<span class="comargs"><em>list_of_linked_libraries)</em></span></li>
					
					<li><strong>library_dirs</strong>(<span class="comargs"><em>directory_lst_to_search_libraries)</em></span></li>
				</ul>
				
				<p>
					Command <strong>project</strong> specifies the project name and the name of the main file (i.e. the name of the file containing function 'main'). 
					The name of the main file is optional. The default name of the main file is the project name with appended extension cpp. If command 
					<strong>project</strong> is not specified, then the name of the main file is 'main.cpp' and the project name is 'main'.
				</p>
				<p>
					Command <strong>compiler</strong> specifies a used compiler name. The default compiler name is 'g++'.  
				</p>
				<p>
					Command <strong>compiler_flags</strong> specifies the compiler flags. The default compiler flags are '-O3 -Wall -std=c++14'.  
				</p>
				<p>
					Command <strong>linker</strong> defines the linker name. The default linker name is the compiler name.  
				</p>
				<p>
					Command <strong>linker_flags</strong> specifies the linker flags. The default flags is ' '.  
				</p>
				<p>
					Command <strong>source_dir</strong> specifies the directory with source code (files with extensions cpp, c++, cxx). The default directory is the current directory.  
				</p>
				<p>
					Command <strong>source_exts</strong> specifies source files extensions (files extensions cpp, c++, cxx, and so on, except header files extensions). 
				</p>
				<p> 
					Command <strong>build_dir</strong>_ specifies a directory with object files and with an executable file. If this command is not specified, the object files and an executable 
					file will be in the root directory of the project. 
				</p>
				<p> 
					Command <strong>include_dirs</strong> specifies the location of header files for external libraries. 
				</p>
				<p> 
					Command <strong>makefile_name</strong> specifies the name of the generated Makefile. The default name of Makefile is Makefile.  
				</p>
				<p>
					Command <strong>libraries</strong> specifies a quoted list of names linked libraries, separated by whitespace chars (i.e. spaces and tabulations). 
					Name format is as follows: you should not include the prefix lib and the suffix .a. 
				</p>
				<p> 
					Command <strong>library_dirs</strong> specifies a quoted list of paths for external libraries search.  
 				</p>
 				
 				<p>
					Here <span class="comargs"><em>project_name</em></span>, <span class="comargs"><em>name_for_Makefile</em></span>, <span class="comargs"><em>compiler_name</em></span>, 
					<span class="comargs"><em>linker_name</em></span> are identifiers. All other arguments are string literals. Here an identifier is any non-empty sequence of Latin letters, 
					decimal digits, characters '+' and '-', underscore and dot; string literal is any (including empty) sequence of characters enclosed in double quotes. If in a string 
					literal you need to specify a double quote, it should be doubled. A string literal that is the value of the argument of the command 
					<span class="comargs">source_exts</em></span> is a list of source code files extensions, delimited by whitespace characters. Extensions must be specified without begin point.   
 				</p>
 				
 				<p>
 					The argument of the command <span class="comargs">include_dirs contains a list separated by semicolons paths to directories containing header files for external libraries.
 				</p>
 				
 				<p>
					The argument of the command <span class="comargs">library_dirs</em></span>_ contains a list separated by semicolons paths to directories containing external libraries.
 				</p>

			<h2 id="examples">3. Examples</h2>
			
				<p>
					Let us give examples of the program Murlyka using. 
				</p>
				
				<h3 id="ex1">Example 1</h3>
					<p>
						Let 'simple01' be a project with the following structure:
					</p>	
					<pre>
	simple01  
	  func1.cpp   
	  func1.h  
	  func2.cpp  
	  func2.h  
	  simple01.cpp  
	  build
					</pre>	
					<p>Suppose that the main file is the file 'simple01.cpp", and the build directory is the directory 'build'. If we put a file (for example, a file with the name 
						'mkdescr.txt') in the project root directory, and this file has the following contents
					</p>	
					<pre>
	project(simple01)  
	compiler(g++)  
	linker(g++)  
	source_exts("cpp")  
	build_dir("build")  
					</pre>
					<p>
						then after processing this file, we will get a Makefile with the following contents:
					</p>					
<pre>
	LINKER      = g++  
	LINKERFLAGS = -s  
	CXX         = g++  
	CXXFLAGS    = -O3 -Wall -std=c++14  
	BIN         = simple01  
	vpath %.o build  
	OBJ         = simple01.o func2.o func1.o  
	LINKOBJ     = simple01.o func2.o func1.o  

	.PHONY: all all-before all-after clean clean-custom

	all: all-before $(BIN) all-after

	clean: clean-custom   
		rm -f ./build/*.o  
		rm -f ./build/$(BIN)

	.cpp.o:  
		$(CXX) -c $< -o $@ $(CXXFLAGS) 

	$(BIN):$(OBJ)  
		$(LINKER) -o $(BIN) $(LINKOBJ) $(LINKERFLAGS)  
		mv $(BIN) $(OBJ) ./build
</pre>								
				
				<h3 id="ex2">Example 2</h3>
					<p>
						Let 'simple02' be a project with the following structure:
					</p>
					<pre>
	simple02  
	  build  
	  include  
	    func1.h  
	    func2.h  
	  src  
	    func1.cpp  
	    func2.cpp  
	    simple02.cpp
					</pre>
					<p>
						In other words, files with the file extension .h located in the directory 'include', and the files with the extension .cpp in the directory 'src'.
						Suppose that the main file is the file 'simple01.cpp", and the build directory is the directory 'build'. If we put a file (for example, a file with 
						the name 'mkdescr.txt') in the project root directory, and this file has the following contents
					</p>
					<pre>
	project(simple02)  
	compiler(g++)  
	linker(g++)  
	source_exts("cpp")  
	source_dir("src")  
	build_dir("build")  
					</pre>
					<p>
						then after processing this file, we will get a Makefile with the following contents:
					</p>		
					<pre>
	LINKER           = g++  
	LINKERFLAGS      = -s  
	COMPILER         = g++  
	COMPILERFLAGS    = -O3 -Wall -std=c++14  
	BIN              = simple02  
	vpath %.cpp src  
	vpath %.o build  
	OBJ              = simple02.o func2.o func1.o  
	LINKOBJ          = build/simple02.o build/func2.o build/func1.o  

	.PHONY: all all-before all-after clean clean-custom

	all: all-before $(BIN) all-after

	clean: clean-custom  
		rm -f ./build/*.o  
		rm -f ./build/$(BIN)  

	.cpp.o:  
		$(CXX) -c $< -o $@ $(CXXFLAGS)   
		mv $@ ./build

	$(BIN):$(OBJ)  
		$(LINKER) -o $(BIN) $(LINKOBJ) $(LINKERFLAGS)  
		mv $(BIN) ./build
					</pre>
					
			<h2 id="cmdline">4. Command line syntax</h2>
				<p>
					Command line syntax for Murlyka is 
				</p>
				<pre>
	$ murlyka option				
				</pre>
				<p>
					or
				</p>
				<pre>
	$ murlyka files				
				</pre>
				<p>
					Here 'option' is either `--help`, or `--version`. First of them displays help, second of them displays version info; 
					'files' are processed configuration files names.
				</p>
				
			<h2 id="building">5. Building of Murlyka project</h2>
				<p>
					To build this project, you need to install Haskell Platform. Suppose that you installed Haskell Platform; then to build the project Murlyka, you need
				</p>
				<pre>
	$ git clone https://github.com/gavr-vlad-s/murlyka
	$ cd murlyka
	$ cabal configure
	$ cabal build			
				</pre>
				
			<h2 id="install-haskell">6. Installing Haskell </h2>
				<h3 id="install-win">For Windows</h3>
					<ol>
						<li>Download installer from <a href="https://www.haskell.org/downloads"><code>https://www.haskell.org/downloads</code></a></li>
						<li>Run downloaded installer. </li>
					</ol>
					
				<h3 id="install-debian">For Debian and Debian-based Linux (e.g., Ubuntu Linux, Linux Mint)</h3>
					<p>
						Execute the following command: 
					</p>
					<pre>
	$ sudo apt-get install haskell-platform					
					</pre>
				
				<h3 id="install-arch">For Arch Linux and for Arch-based Linux (e.g., Manjaro Linux)</h3>
					<p>
						Execute the following command: 
					</p>
					<pre>
	$ sudo pacman -S ghc cabal-install haskell-haddock-api haskell-haddock-library happy alex
					</pre>
							
			<h2 id="releases">7. Releases</h2>
				<p>
					There are binary releases:
					<ol>
						<li>
							<p><a href="https://github.com/gavr-vlad-s/murlyka/releases/download/v1.1.0/murlyka-1.1.0-windows-amd64.zip">release for Windows 7 64-bit.</a></p>
						</li>
					</ol>
					
				</p>  
				<p> You can download html-documentation:
					<ol>
						<li>
							<p><a href="https://github.com/gavr-vlad-s/murlyka-docs/releases/download/v1.1/murlyka-manual-en.html">English html doc.</a></p>
						</li>
					</ol>					
				</p>
		</article>
	</section>
	<footer>
		<address>
			<a href="mailto:">vladimir.s.gavrilov@gmail.com</a>
		</address>
		<p>&copy; Copyright 2017 </p>
	</footer>
</body>
</html>